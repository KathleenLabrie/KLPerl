#!/usr/local/bin/perl -w
#
#Package: Plot::SM
#Name: sm_medcount
#Version: 1.1.0
$prog = 'sm_medcount';
$version = '1.1.0';
#	Generate a SM macro file called /astro/labrie/sm/macro/datared/darkcurrent or
#	/astro/labrie/sm/datared/flatlevel.
#	Macros: oneetime : Evolution of counts for a given etime
#		 varetime : Evolution of counts with increasing etime
#
# Usage: sm_darkcurrent files --dir=directory  --calibtype  --filter=filter
#
#	--calibtype: 		[dark|flat]
#	--filter=filter:	Specify filter name to be appended to eps file

use lib qw(/home/labrie/prgp/include);
use Util;
use Plot::SM;

#Defaults
$macrofile = "$SM::MACRODIR/datared";
$TRUE=1;
$x1=0;
$xshift=0;
$moreParam{'filter'}='';
#$moreParam{'dir'} = '.';

#Create the macro directory, if necessary
if (!(-e $macrofile) and !(-d $macrofile)) {
  mkdir $macrofile, 0755;
}

#Parse command line
while ($_ = shift @ARGV) {
  SWITCH: {
    if ( /--/ ) {
      s/--//;
      if (/=/) { ($key,$value) = split /=/; }
      else     { $key = $_; $value = 1;     }
      $moreParam{$key} = $value;
      last SWITCH;
    }
    push @files, $_;
  }
}

SWITCH: {
  if (defined $moreParam{'dark'} and $moreParam{'dark'} == $TRUE) {
    $macrofile .= '/darkcurrent';
    last SWITCH;
  }
  if (defined $moreParam{'flat'} and $moreParam{'flat'} == $TRUE) {
    $macrofile .= '/flatlevel';
    last SWITCH;
  }
}

#define array of hashes.  (1 record per file)
@records = ();
foreach $file (@files) {
  $rec = {};
  if (defined $moreParam{'dir'}) {
    $rec->{'file'} = $moreParam{'dir'}.'/'.$file;
    $rec->{'file'} =~ s/\/\//\//g;
  }
  else { $rec->{'file'} = $file; }

  open(INPUT, "<$file") or die "Unable to open $file for reading.\n";
  @lines = <INPUT>;
  close(INPUT);
  @values = ();
  foreach $line (@lines) {
	next if ($line =~ /^#/); 
  	$line =~ s/\n//; 
	@elem = split /\s+/, $line;
	push @values, $elem[0];
  }
  

  #define x1 x2
  $rec->{'x1'} = $x1;
  $rec->{'x2'} = $#values + 2;

  #etime
  $file =~ /.+?(\d+)\.\w+/;
  $seconds = $1;
  $seconds =~ s/^0/0\./;
  $rec->{'etime'} = $seconds;

  #calculate median
  $rec->{'median'} = Util::median(@values);

  #calculate stddev
  $rec->{'stddev'} = Util::stddev(@values);

  #estimate y1 y2
  $rec->{'y1'} = int($rec->{'median'} - ($rec->{'stddev'} * 8));
  $rec->{'y2'} = int($rec->{'median'} + ($rec->{'stddev'} * 8));

  push @records, $rec;
}

@etimes=();
@meds=();
@sigs=();
sub etime { $a->{'etime'} <=> $b->{'etime'}; }

if ($moreParam{'dark'}) {
  $title="# Macros for dark current analysis\n\n";
  $plotName='darkcurrent.eps';
  $calib='Dark';
  $xaxis='logx';
}
elsif ($moreParam{'flat'}) {
  $title="# Macros for flat level analysis\n\n";
  $plotName='flatlevel'.$moreParam{'filter'}.'.eps';
  $calib='Flat';
  $xaxis='x';
}
else {die "ERROR: No calibration type specified.\n";}

#-----------
$oneetime = '
oneetime 8	# Plot '.lc($calib).' level for series of images
		# filename x1 x2 y1 y2 median stddev seconds
		erase
		data $1
		lines 0 0
		read y 1
		set x = 1, dimen(y)
		limits $2 $3 $4 $5
		if ($3 < 10) { 
			define bigx (1)
		} else { if ($3 < 20) { 
			define bigx (2)
		} else { if ($3 < 50) { 
			define bigx (5) 
		} else { if ($3 < 100) {
			define bigx (10)
		}}}}
		ticksize 1 $bigx 0 0
		box
		ptype 4 0
		points x y
		set med = <$6 $6>
		set i = <$2 $3>
		connect i med
		set upper = med + $7
		set lower = med - $7
		ltype 2
		connect i upper
		connect i lower
		ltype 0
		lweight 0
		ctype black
		xlabel "'.$calib.'"
		ylabel "'.$calib.' Level (median) [counts]"
		aspect 2
		toplabel $8 seconds '.lc($calib).'s
		aspect 1
		lweight 0
		ltype 0
		ctype black
';

$varetime = '
		box
		ptype 4 0
		points '.$xaxis.' y
		load utils
		error_y '.$xaxis.' y sigma
		unload utils
		xlabel "Exposure time [sec]"
		ylabel "'.$calib.' Level (median) [counts]"
		aspect 2
		toplabel "'.$calib.' Level vs Exposure Time"
		aspect 1
';
#-----------

open (OUTPUT, ">$macrofile") or die "Unable to open $macrofile for writting.\n";
print OUTPUT "# Generated by $prog Version $version\n";
print OUTPUT "$title";
print OUTPUT "plotcalib\t#Plot calibs' counts\n";
print OUTPUT "\t\tmacro READ \"$SM::MACRODIR/printmacro\"\n";
print OUTPUT "\t\tsm2ps 0 varetime $plotName\n";
foreach $rec (@records) {
  $rec->{'file'} =~ /(.+?)\.dat$/;
  print OUTPUT "\t\tsm2ps 0 plot$rec->{'etime'} $1.eps\n";
}
foreach $rec (@records) {
  print OUTPUT "\nplot$rec->{'etime'}\t\t#Plot $rec->{'etime'} seconds ".
  		 lc${calib}."s\n";
  if ($rec->{'median'} > 10000) { $xshift=1000; }
  print OUTPUT "\t\tlocation \$(\$gx1 + $xshift) \$gx2 \$gy1 \$gy2\n";
  print OUTPUT "\t\toneetime \"$rec->{'file'}\" $rec->{'x1'} $rec->{'x2'} ",
  		 "$rec->{'y1'} $rec->{'y2'} $rec->{'median'} $rec->{'stddev'} ",
		 "$rec->{'etime'}\n";
  print OUTPUT "\t\tlocation \$(\$gx1 - $xshift) \$gx2 \$gy1 \$gy2\n";
}
print OUTPUT $oneetime;
print OUTPUT "\nvaretime\t# Plot ".lc($calib)." level for different etime\n";
#print OUTPUT "\t\t#y1 y2\n";
print OUTPUT "\t\terase\n";
$max=-1E32;
$min=1E32;
foreach $rec (sort etime @records) {
  push @etimes, $rec->{'etime'};
  push @meds, $rec->{'median'};
  push @sigs, $rec->{'stddev'};
  if ($rec->{'median'}+($rec->{'stddev'}*2) > $max) {
  	$max = $rec->{'median'}+($rec->{'stddev'}*2);
  }
  if ($rec->{'median'}-($rec->{'stddev'}*2) < $min) {
  	$min = $rec->{'median'}-($rec->{'stddev'}*2);
  }
}
print OUTPUT "\t\tset x = <@etimes>\n";
if ($moreParam{'dark'}) {print OUTPUT "\t\tset logx = lg(x)\n";}
print OUTPUT "\t\tset y = <@meds>\n";
print OUTPUT "\t\tset sigma = <@sigs>\n";
if ($moreParam{'dark'}) {
	print OUTPUT "\t\tlimits logx ",$min," ",$max;
	print OUTPUT "\t\tticksize -1 0 0 0\n";
}
else {
	print OUTPUT "\t\tlimits x ",$min," ",$max;
	print OUTPUT "\t\tticksize 0 0 0 0\n";
	$xshift=1000;
}
print OUTPUT "\t\tlocation \$(\$gx1 + $xshift) \$gx2 \$gy1 \$gy2\n";
print OUTPUT $varetime;
print OUTPUT "\t\tlocation \$(\$gx1 - $xshift) \$gx2 \$gy1 \$gy2\n";
close (OUTPUT);

exit(0);
